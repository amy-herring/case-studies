---
title: "Multi-Level Regression and Poststratification Tutorial"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lme4)
library(brms)
library(rstan)
#library(albersusa)
#library(cowplot)
```

### Introduction

It is often of interest to researchers to look into state-level opinion, in addition to or instead of national-level opinions prior to elections. However, finding surveys that are uniform across all or most states is extremely challenging. One method of estimating state-level opinion using national survey data is called **multilevel modeling with poststratification**. This method begins by using multilevel regression to model individual survey responses as a function of demographic and geographic predictors. Then doing poststratification, in which the estimates for each demographic-geographic respondent type are weighted (poststratified) by the percentages of each type in the actual state populations.


In this tutorial, we will be going to through a tutorial for implementing this method, and then explore a Bayesian version of it.

### The Data

Obtain the three data sets from the following link: [MRP Primer](http://www.princeton.edu/~jkastell/mrp_primer.html)

```{r}
# importing packages

library("arm")
library("foreign")
```


### Step 1: Gather National Opinion Poll(s)

These polls should include some respondent demographic information and some type of geographic indicator such as state. In this tutorial we'll be using the "gay_marriage_megapoll.dta" set which contains five national polls that were conducted in 2004.

### Step 2: If necessary, recode these polls so that they can be combined into a single internally-consistent dataset.

For this step, you may rename columns so that the data sets can be merged properly. For our dataset this has already been completed.

```{r}
#read in megapoll and attach
# Note: replace with the location of the file on your local computer
marriage.data <- read.dta("data/gay_marriage_megapoll.dta",
          convert.underscore = TRUE) #convert variables names with underscores to periods

```

### Step 3: Create A Separate Dataset of State-Level Predictors

We may wish to model state-level effects in our multilevel regression. To do this we will use state-level predictiors, e.g. region/state-level demographics. This will reduce the unexplained group level variation. In this tutorial, we already have a data set with state-level information in it.

```{r}
#read in state-level dataset
Statelevel <- read.dta("data/state_level_update.dta",convert.underscore = TRUE)
Statelevel <- Statelevel[order(Statelevel$sstate.initnum),]
```

### Step 4: Collecting census data to enable poststratificaiton

We will need census data to complete the poststratification later in the tutorial. This data must correspond to all individual-level demographic variables included in our model. Ultimately, we need a dataset of the population counts for each demographic-state type, e.g. how many African Americans between 18-25 went to college and reside in North Carolina. For this tutorial, we will use the 5% Public Use Microdata Sample from the 2000 census. 

```{r}
#read in Census data
Census <- read.dta("data/poststratification 2000.dta",convert.underscore = TRUE)
Census <- Census[order(Census$cstate),]
Census$cstate.initnum <-  match(Census$cstate, Statelevel$sstate)
```

### Step 5: Creating Index Variables

Next we will create index variables so that we can use our individual-level model and in the poststratification step.

```{r}
# Create index variables

#At level of megapoll

marriage.data$race.female <- (marriage.data$female *3) + marriage.data$race.wbh# from 1 for white males to 6 for hispanic females
marriage.data$age.edu.cat <- 4 * (marriage.data$age.cat -1) + marriage.data$edu.cat# from 1 for 18-29 with low edu to 16 for 65+ with high edu
marriage.data$p.evang.full <- Statelevel$p.evang[marriage.data$state.initnum]# proportion of evangelicals in respondent's state
marriage.data$p.mormon.full <-Statelevel$p.mormon[marriage.data$state.initnum]# proportion of mormon's in respondent's state
marriage.data$p.relig.full <- marriage.data$p.evang.full + marriage.data$p.mormon.full# combined evangelical + mormom proportions
marriage.data$p.kerry.full <- Statelevel$kerry.04[marriage.data$state.initnum]# kerry's % of 2-party vote in respondent's state in 2004

#At census level (same coding as above for all variables)

Census$crace.female <- (Census$cfemale *3) + Census$crace.WBH 
Census$cage.edu.cat <- 4 * (Census$cage.cat -1) + Census$cedu.cat 
Census$cp.evang.full<-  Statelevel$p.evang[Census$cstate.initnum]
Census$cp.mormon.full <- Statelevel$p.mormon[Census$cstate.initnum]
Census$cp.relig.full <- Census$cp.evang.full + Census$cp.mormon.full
Census$cp.kerry.full <-  Statelevel$kerry.04[Census$cstate.initnum]
```

### Step 6: Fitting our individual-level regression model.

Now we are ready to fit a regression model for an individual survey response on gay marriage rights given demographics and geography, i.e. each individual's response will be a function of their demographics and state. We'll denote each individual as *i* with indices *j, k, l, m, s,* and *p* for race-gender combination, age category, education category, region, state, and poll respectively, and including an age-education interaction. More specifically, we denote $y_i$ as 1 for supporters of same-sex marriage and 0 for opponents and those with no opinion. Remember that since we're modeling a binary variables we ought to use logistic regression, and thus our model will be as follows:

\[
\mathrm{Pr}(y_i = 1) = \mathrm{logit}^{-1}(\beta^0 + \alpha^{race,gender}_{j[i]} + \alpha^{age}_{k[i]} + \alpha^{edu}_{l[i]} + \alpha^{age,edu}_{k[i],l[i]} + \alpha^{state}_{s[i]} + \alpha^{year}_{p[i]})
\]

We can think of the terms after the intercept as modeled effects for different groups of respondents such as individuals who are a specific age. All of them except the state coefficient will be model as drawn from a normal distribution with mean zero and some estimated variance specific to that variable. For example,

\[
\alpha^{poll}_p \sim N(0, \sigma^2_{poll}), \mathrm{p = 1, ..., n}
\]

For the state effect, we'll be doing something slightly different. Instead of having a distribution with mean equaling zero, we will be modeling it as a function of the the region into which the state falls and the state’s conservative religious percentage and Democratic 2004 presidential vote share:^[These are just some examples of group-level predictors which reduce unexplained group-level variation, and thus lead to more precise estimation (Gelman and Hill 2007, 271)]

\[
\alpha^{state}_s \sim N(\alpha^{region}_{m[s]} + \beta^{relig}\cdot relig_s + \beta^{presvote} \cdot presvote_s, \sigma^2_{state}), \mathrm{s = 1, ..., 51}
\]

(Note: we model the region variable identically to the previous variables, e.g. poll.)

Now we're ready to move onto coding up this model:

```{r}
#run individual-level opinion model

individual.model <- glmer(formula = yes.of.all ~ (1|race.female) + (1|age.cat) + (1|edu.cat) + (1|age.edu.cat) + (1|state) + (1|region) + (1|poll) + p.relig.full + p.kerry.full,data=marriage.data, family=binomial(link="logit")) # Note: (1|variable) denotes a random effect
display(individual.model)

#examine random effects and standard errors for race-female
ranef(individual.model)$race.female
se.ranef(individual.model)$race.female

# Since we do not have any respondents from Alaska or Hawaii, we have to create a vector of state random effects that accounts for these states.
state.ranefs <- array(NA,c(51,1))
dimnames(state.ranefs) <- list(c(Statelevel$sstate),"effect")
for(i in Statelevel$sstate){
  state.ranefs[i,1] <- ranef(individual.model)$state[i,1]
}
state.ranefs[,1][is.na(state.ranefs[,1])] <- 0 #set states with missing REs (b/c not in data) to zero
```

This logistic regression gives the probability that any adult will support same-sex marriage given the person’s sex, race, age, education, and state.

### Step 7: Poststatify the demographic-geographic types

To complete this method, we need to compute a weighted average of the probabilities from the logistic regression to estimate the proportin of same-sex marriage supporters in each state. First, need to create a prediction for each demographic-state combination (each cell in Census data):

```{r}
#create a prediction for each cell in Census data
cellpred <- invlogit(fixef(individual.model)["(Intercept)"]
                     +ranef(individual.model)$race.female[Census$crace.female,1]
                     +ranef(individual.model)$age.cat[Census$cage.cat,1]
                     +ranef(individual.model)$edu.cat[Census$cedu.cat,1]
                     +ranef(individual.model)$age.edu.cat[Census$cage.edu.cat,1]
                     +state.ranefs[Census$cstate,1]
                     +ranef(individual.model)$region[Census$cregion,1]   
                     +(fixef(individual.model)["p.relig.full"] *Census$cp.relig.full)
                     +(fixef(individual.model)["p.kerry.full"] *Census$cp.kerry.full)
)
```

Then this prediction needs to be weighted by the actual population frequency of that state. Using this we can then calculate the average response, over each cell *j* in state *s*:

\[

y^{MRP}_{s} = \frac{\sum_{c\in s}N_c\theta_c}{\sum_{c \in s} N_c}
\]

More concretely, we would compute this using the following code:

```{r}
#weights the prediction by the freq of cell                                       
cellpredweighted <- cellpred * Census$cpercent.state

#calculates the percent within each state (weighted average of responses)
statepred <- 100* as.vector(tapply(cellpredweighted,Census$cstate,sum))
statepred
```

This result is a set a state-level opinion estimates that you could use to help make predictions regarding the election. 

### Bayesian Model
We could also implement this model using Stan which allows for quantifying model uncertainity. The model specification will be the same our other section, except for some weakly informative priors on the standard deviations of the varying intercepts useful for convergence.

```{r, cache = TRUE}
library(rstan)
library(brms)

# the model
bayes.mod <- brm(yes.of.all ~ (1|race.female) + (1|age.cat) + (1|edu.cat)
                 + (1|age.edu.cat) + (1|state) + (1|region)
                 + p.relig.full + p.kerry.full,
                 data=marriage.data, family=bernoulli(),
                 prior=c(set_prior("normal(0,0.2)", class='b'),
                         set_prior("normal(0,0.2)", class='sd', group="race.female"),
                         set_prior("normal(0,0.2)", class='sd', group="age.cat"),
                         set_prior("normal(0,0.2)", class='sd', group="edu.cat"),
                         set_prior("normal(0,0.2)", class='sd', group="age.edu.cat"),
                         set_prior("normal(0,0.2)", class='sd', group="state"),
                         set_prior("normal(0,0.2)", class='sd', group="region")))

summary(bayes.mod)

# Model Uncertainity: standard deviation of group-level intercepts
# install.packages("devtools")
# devtools::install_github("mjskay/tidybayes")
library(tidybayes)

approx_sd <- broom::tidy(individual.model) %>%
  filter(stringr::str_detect(term, "sd_"))

bayes.mod %>%
  gather_samples(`sd_.*`, regex=TRUE) %>%
  ungroup() %>%
  mutate(group = stringr::str_replace_all(term, c("sd_" = "","__Intercept"=""))) %>%
  ggplot(aes(y=group, x = estimate)) + 
  ggridges::geom_density_ridges(aes(height=..density..),
                                rel_min_height = 0.01, stat = "density",
                                scale=1.5) + 
  geom_point(data=approx_sd)

# Edit Census data for use
Census$p.relig.full <- Census$cp.relig.full
Census$p.kerry.full <-  Census$cp.kerry.full

# point estimate for the level of state support for gay marriage and poststratify
ps.bayes.mod <- bayes.mod %>%
  add_predicted_draws(newdata=Census, allow_new_levels=TRUE) %>%
  rename(support = .prediction) %>%
  mean_qi() %>%
  mutate(support = support * cpercent.state) %>%
  group_by(cstate) %>%
  summarise(support = sum(support))
```

